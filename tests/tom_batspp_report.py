#! /usr/bin/env python

#| NOTE: USES batspp 1.X.X (simple_batspp.py), mezcla & kcov || MAY NOT WORK PROPERLY ON FIRST RUN
## SCRIPT_NAME : batspp_report.py
#| BUG: NO EXECUTION ON FIRST TRY
#| TODO: Avoid tests (e.g. sudo tests) having "NOBATSPP" on the title | --all selects all testfiles 

"""
  Test automation & report generation for ipynb test files (for BatsPP 1.5.X).
  BatsPP files are generated by default (stored at ./batspp-only).
"""

## TEMP
## pylint: disable=f-string-without-interpolation

from mezcla import debug
from mezcla import glue_helpers as gh
from mezcla import system as msy
from mezcla.main import Main
from mezcla.my_regex import my_re

TL = debug.TL

IPYNB = ".ipynb"
BATSPP = ".batspp"
BATS = ".bats"
TXT = ".txt"
NOBATSPP = "NOBATSPP"

BATSPP_STORE = "batspp-only"
BATS_STORE = "bats-only"
TXT_STORE = "txt-reports"
KCOV_STORE = "kcov-output"


ESSENTIAL_DIRS = [BATSPP_STORE, BATS_STORE, KCOV_STORE, TXT_STORE]

ESSENTIAL_DIRS_present = all(gh.file_exists(dir) for dir in ESSENTIAL_DIRS)

TEST_REGEX = msy.getenv_value("TEST_REGEX", None,
                              "Regex for tests to include; ex: 'c.*' for debugging")

def main():
    """Entry point"""
    
    files = msy.read_directory("./")
    
    # 0.1) CHECKING IF THE DIRECTORY EXISTS
    
    if not ESSENTIAL_DIRS_present:
        gh.create_directory(BATS_STORE)
        gh.create_directory(BATSPP_STORE)
        gh.create_directory(TXT_STORE)
        gh.create_directory(KCOV_STORE)
        
    batspp_count = 0
    
    # 0.2) Option Parsing

    # Parse command line options, show usage if --help given
    NO_REPORTS_ARG = "no"
    KCOV_REPORTS_ARG = "kcov"
    TEXT_REPORTS_ARG = "txt"
    ALL_REPORTS_ARG = "all"
    BATSPP_SWITCH_ARG = "switch"
    main_app = Main(description=__doc__.format(script=gh.basename(__file__)).strip("\n"),
                    boolean_options=[
                        (NO_REPORTS_ARG, "No reports are generated, testfiles are shown"),
                        (KCOV_REPORTS_ARG, f"KCOV (HTML based) reports generated, stored at ./{KCOV_STORE}"),
                        (TEXT_REPORTS_ARG, f"Textfile based reports generated, stored at ./{TXT_STORE}"),
                        (ALL_REPORTS_ARG, "Generates report for all available testfiles (NOBATSPP testfiles were ignored by default)"),
                        (BATSPP_SWITCH_ARG, "Uses batspp library instead of ../simple_batspp.py script")],
                    skip_input=False, manual_input=False, short_options=True)
    debug.assertion(main_app.parsed_args)
    #
    NO_OPTION = main_app.get_parsed_option(NO_REPORTS_ARG)
    TXT_OPTION = main_app.get_parsed_option(KCOV_REPORTS_ARG)
    KCOV_OPTION = main_app.get_parsed_option(TEXT_REPORTS_ARG)
    ALL_OPTION = main_app.get_parsed_option(ALL_REPORTS_ARG)
    BATSPP_SWITCH_OPTION = main_app.get_parsed_option(BATSPP_SWITCH_ARG)
    
    if not NO_OPTION:
        gh.run(f"rm -rf ./{BATSPP_STORE}/*")
        gh.run(f"rm -rf ./{BATS_STORE}/*")
        
    if KCOV_OPTION:
        gh.run(f"rm -rf ./{KCOV_STORE}/*")
    
    BATSPP_SWITCH_COND = "PARA_BLOCKS=1 ../simple_batspp.py" if not BATSPP_SWITCH_OPTION else "batspp"
    
    
    # 1) Identifying .ipynb files
    i = 1
    ipynb_array = []
    avoid_array = []
    avoid_count = 0
    
    print(f"\n=== BATSPP REPORT GENERATOR (simple_batspp.py / BATSPP 1.5.X) ===\n")
    
    for file in files:
        is_ipynb = file.endswith(IPYNB)
        if is_ipynb:
            if TEST_REGEX and not my_re.match(fr"^{TEST_REGEX}$", file):
                debug.trace(3, f"Ignoring {file}")
                continue
            if not ALL_OPTION and NOBATSPP in file:      
                    print(f"NOBATSPP File Found [{i}]: {file}")
                    avoid_array += [file]
                    avoid_count += 1
            else: 
                print(f"JUPYTER Testfile Found [{i}]: {file}")
                ipynb_array += [file]
            i += 1
    
    print(f"\nIPYNB Files Found (Total - NOBATSPP): {i-1} - {avoid_count} = {i-avoid_count-1}")
    
    # 2) Generating .batspp files from .ipynb files
    
    i = 1
    batspp_array = []
    print(f"\n=== GENERATING BATSPP FILES ===\n")
    
    for testfile in ipynb_array:
        is_ipynb = testfile.endswith(IPYNB)
        if is_ipynb:
            batspp_from_ipynb = testfile.replace(IPYNB, BATSPP)
            print (f"IPYNB TESTFILE [{i}]: {testfile} => {batspp_from_ipynb}")
            gh.run(f"./jupyter_to_batspp.py {testfile} --output ./{BATSPP_STORE}/{batspp_from_ipynb}")
            batspp_array += [batspp_from_ipynb]
            i += 1
    
    ipynb_count = i - 1
    
    # 3) Executing batspp files & storing them as bats
    
    print (f"\n\n==========BATS GENERATED==========\n") 
    i = 1   
    
    if NO_OPTION == 1:
        print(f">> SKIPPING BATSPP CHECK (-n ARGUMENT PROVIDED)\n")
    else:
        for batsppfile in batspp_array:
            is_batspp = batsppfile.endswith(BATSPP)
            if is_batspp:
                bats_from_batspp = batsppfile.replace(BATSPP, BATS)
                txt_from_batspp = batsppfile.replace(BATSPP, TXT)
                kcov_folder = gh.remove_extension(batsppfile, BATSPP)
                
                print(f"\nBATSPP FILE DETECTED [{i}]: {batsppfile} => {bats_from_batspp}\n")
                
                if TXT_OPTION == 1:
                    TXT_MESSAGE = f"REPORT PATH: ./{TXT_STORE}/{txt_from_batspp}"
                    gh.run(f"{BATSPP_SWITCH_COND} ./{BATSPP_STORE}/{batsppfile} --output ./{TXT_STORE}/{txt_from_batspp}")
                    print (gh.indent(TXT_MESSAGE, indentation="  >>  ", max_width=512))
                    i += 1
    
                else:
                    gh.run(f"{BATSPP_SWITCH_COND} ./{BATSPP_STORE}/{batsppfile} --output ./{BATS_STORE}/{bats_from_batspp}")
                    i += 1
                    
                    if KCOV_OPTION == 1:
                        KCOV_MESSAGE = f"KCOV REPORT PATH: ./{KCOV_STORE}/{kcov_folder}/"
                        print(gh.indent(KCOV_MESSAGE, indentation="  >>  ", max_width=512))
                        gh.run(f"kcov ./{KCOV_STORE}/{kcov_folder} bats ./{BATS_STORE}/{bats_from_batspp}")
                    
        batspp_count = i - 1 
    
    # 4) Mentioning any errors in ipynb testfiles
    working_testfiles = []
    
    for file in batspp_array:
        is_batspp = file.endswith(BATSPP)
    
        if is_batspp:
            BI_check = [file.replace(".batspp", ".ipynb")]
            working_testfiles += BI_check
    
    # 5) Summary Statistics
    set_wt = set(working_testfiles)
    error_testfiles = [tf for tf in ipynb_array if tf not in set_wt]
    faulty_count = ipynb_count - batspp_count
    
    print(f"\n======================================================")
    print(f"SUMMARY STATISTICS:\n")
    print(f"simple_batspp.py used: {bool(BATSPP_SWITCH_OPTION)}")
    print(f"No. of IPYNB testfiles: {ipynb_count + avoid_count}")
    print(f"No. of BATSPP files (generated): {batspp_count if TXT_OPTION or NO_OPTION != 1 else 'NaN'}")
    print(f"No. of FAULTY testfiles: {faulty_count if TXT_OPTION or NO_OPTION != 1 else 'NaN'}")
    print(f"No. of AVOIDED testfiles: {avoid_count}")
    
    print(f"\nFAULTY TESTFILES:")
    if faulty_count == 0:
        print ("NaN")
    else: 
        for tf in error_testfiles:  
            print(f">> {tf}")
    
    print("\nAVOIDED TESTFILES:")
    if avoid_count == 0:
        print ("NaN")
    else: 
        for tf in avoid_array:  
            print(f">> {tf}")
            
    print(f"======================================================")

#-------------------------------------------------------------------------------

if __name__ == '__main__':
    debug.trace_current_context(level=TL.QUITE_DETAILED)
    main()
