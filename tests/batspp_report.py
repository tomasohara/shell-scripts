#! /usr/bin/env python

#| NOTE: USES batspp 1.X.X (simple_batspp.py), mezcla & kcov || MAY NOT WORK PROPERLY ON FIRST RUN
## SCRIPT_NAME : batspp_report.py
#| BUG: NO EXECUTION ON FIRST TRY
#| TODO: Avoid tests (e.g. sudo tests) having "NOBATSPP" on the title | --all selects all testfiles 

""" 
    TEST AUTOMATION & REPORT GENERATION FOR IPYNB TEST FILES (FOR BATSPP 1.5.X)
    BATSPP FILES ARE GENERATED BY DEFAULT (stored at ./batspp-only)
"""

from mezcla import glue_helpers as gh
from mezcla import system as msy
from mezcla.main import Main

from optparse import OptionParser

IPYNB = ".ipynb"
BATSPP = ".batspp"
BATS = ".bats"
TXT = ".txt"
NOBATSPP = "NOBATSPP"

BATSPP_STORE = "batspp-only"
BATS_STORE = "bats-only"
TXT_STORE = "txt-reports"
KCOV_STORE = "kcov-output"


ESSENTIAL_DIRS = [BATSPP_STORE, BATS_STORE, KCOV_STORE, TXT_STORE]

ESSENTIAL_DIRS_present = all(gh.file_exists(dir) for dir in ESSENTIAL_DIRS)

files = msy.read_directory("./")

# 0.1) CHECKING IF THE DIRECTORY EXISTS

if not ESSENTIAL_DIRS_present:
    gh.create_directory(BATS_STORE)
    gh.create_directory(BATSPP_STORE)
    gh.create_directory(TXT_STORE)
    gh.create_directory(KCOV_STORE)
    
filesys_bpp = msy.read_directory("./batspp-only")
filesys_bats = msy.read_directory("./bats-only")
batspp_count = 0

# 0.2) Option Parsing

usage = "%prog [options]"
parser = OptionParser(usage=usage)

parser.add_option(
    "-n", "--no",
    dest="no_option",
    default=0,  
    action="count", 
    help="No reports are generated, testfiles are shown"
)

parser.add_option(
    "-k", "--kcov", 
    dest="kcov_option",
    default=0,
    action="count", 
    help=f"KCOV (HTML based) reports generated, stored at ./{KCOV_STORE}/"
)

parser.add_option(
    "-t", "--txt",
    default=0,
    dest="txt_option",
    action="count", 
    help=f"Textfile based reports generated, stored at ./{TXT_STORE}"
)

parser.add_option(
    "-a", "--all",
    default=0,
    dest="all_option",
    action="count", 
    help=f"Generates report for all available testfiles (NOBATSPP testfiles were ignored by default)"
)

parser.add_option(
    "-s", "--switch",
    default=0,
    dest="batspp_switch_option",
    action="count", 
    help=f"Uses batspp library instead of ../simple_batspp.py script"
)

(options, args) = parser.parse_args()

NO_OPTION = options.no_option
TXT_OPTION = options.txt_option
KCOV_OPTION = options.kcov_option
ALL_OPTION = options.all_option
BATSPP_SWITCH_OPTION = options.batspp_switch_option

if not NO_OPTION:
    gh.run(f"rm -rf ./{BATSPP_STORE}/*")
    gh.run(f"rm -rf ./{BATS_STORE}/*")
    
if KCOV_OPTION:
    gh.run(f"rm -rf ./{KCOV_STORE}/*")

BATSPP_SWITCH_COND = "PARA_BLOCKS=1 ../simple_batspp.py" if not BATSPP_SWITCH_OPTION else "batspp"


# 1) Identifying .ipynb files
i = 1
ipynb_array = []
avoid_array = []
avoid_count = 0

print("\n=== BATSPP REPORT GENERATOR (simple_batspp.py / BATSPP 1.5.X) ===\n")

for file in files:
    is_ipynb = file.endswith(IPYNB)
    if is_ipynb:
        if not ALL_OPTION and NOBATSPP in file:      
                print(f"NOBATSPP File Found [{i}]: {file}")
                avoid_array += [file]
                avoid_count += 1
        else: 
            print(f"JUPYTER Testfile Found [{i}]: {file}")
            ipynb_array += [file]
        i += 1

print(f"\nIPYNB Files Found (Total - NOBATSPP): {i-1} - {avoid_count} = {i-avoid_count-1}")

# 2) Generating .batspp files from .ipynb files

i = 1
print(f"\n=== GENERATING BATSPP FILES ===\n")

for testfile in ipynb_array:
    is_ipynb = testfile.endswith(IPYNB)
    if is_ipynb:
        batspp_from_ipynb = testfile.replace(IPYNB, BATSPP)
        print (f"IPYNB TESTFILE [{i}]: {testfile} => {batspp_from_ipynb}")
        gh.run(f"./jupyter_to_batspp.py {testfile} --output ./{BATSPP_STORE}/{batspp_from_ipynb}")
        i += 1

ipynb_count = i - 1

# 3) Executing batspp files & storing them as bats

print ("\n\n==========BATS GENERATED==========\n") 
i = 1   

if NO_OPTION == 1:
    print(">> SKIPPING BATSPP CHECK (-n ARGUMENT PROVIDED)\n")
else:
    for batsppfile in filesys_bpp:
        is_batspp = batsppfile.endswith(BATSPP)
        if is_batspp:
            bats_from_batspp = batsppfile.replace(BATSPP, BATS)
            txt_from_batspp = batsppfile.replace(BATSPP, TXT)
            kcov_folder = gh.remove_extension(batsppfile, BATSPP)
            
            print(f"\nBATSPP FILE DETECTED [{i}]: {batsppfile} => {bats_from_batspp}\n")
            
            if TXT_OPTION == 1:
                TXT_MESSAGE = f"OUTPUT PATH: ./{TXT_STORE}/{txt_from_batspp}"
                # gh.run(f"{BATSPP_SWITCH_COND} ./{BATSPP_STORE}/{batsppfile} --output ./{TXT_STORE}/{txt_from_batspp}")
                print (gh.indent(TXT_MESSAGE, indentation="  -  ", max_width=512))
                i += 1

            else:
                gh.run(f"{BATSPP_SWITCH_COND} ./{BATSPP_STORE}/{batsppfile} --output ./{BATS_STORE}/{bats_from_batspp}")
                i += 1
                
                if KCOV_OPTION == 1:
                    KCOV_MESSAGE = f"KCOV REPORT PATH: ./{KCOV_STORE}/{kcov_folder}/"
                    print(gh.indent(KCOV_MESSAGE, indentation="  >>  ", max_width=512))
                    gh.run(f"kcov ./{KCOV_STORE}/{kcov_folder} bats ./{BATS_STORE}/{bats_from_batspp}")
                
    batspp_count = i - 1 

# 4) Mentioning any errors in ipynb testfiles
working_testfiles = []

for file in filesys_bpp:
    is_batspp = file.endswith(BATSPP)

    if is_batspp:
        BI_check = [file.replace(".batspp", ".ipynb")]
        working_testfiles += BI_check

# 5) Summary Statistics
set_wt = set(working_testfiles)
error_testfiles = [tf for tf in ipynb_array if tf not in set_wt]
faulty_count = ipynb_count - batspp_count

print(f"\n======================================================")
print(f"SUMMARY STATISTICS:\n")
print(f"simple_batspp.py used: {bool(BATSPP_SWITCH_OPTION)}")
print(f"No. of IPYNB testfiles: {ipynb_count + avoid_count}")
print(f"No. of BATSPP files (generated): {batspp_count if TXT_OPTION or NO_OPTION != 1 else 'NaN'}")
print(f"No. of FAULTY testfiles: {faulty_count if TXT_OPTION or NO_OPTION != 1 else 'NaN'}")
print(f"No. of AVOIDED testfiles: {avoid_count}")

print(f"\nFAULTY TESTFILES:")
if faulty_count == 0:
    print ("NaN")
else: 
    for tf in error_testfiles:  
        print(f">> {tf}")

print(f"\nAVOIDED TESTFILES:")
if avoid_count == 0:
    print ("NaN")
else: 
    for tf in avoid_array:  
        print(f">> {tf}")
        
print(f"======================================================")