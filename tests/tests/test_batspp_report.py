#! /usr/bin/env python
#
# Tests for tom_batspp_report.py module

"""Tests for tom_batspp_report.py module"""

# Standard packages
import unittest
import re

# Installed packages
import pytest

# Local modules
from mezcla.unittest_wrapper import TestWrapper
from mezcla import debug
from mezcla import glue_helpers as gh
from mezcla import system
from mezcla.main import Main
from mezcla.my_regex import my_re

SCRIPT = gh.resolve_path("tom_batspp_report.py")


class TestTomBatsppReport(TestWrapper):
    """Class for testcase definition"""

    def test_txt_report_format(self):
        """Tests txt report format"""
        txt_report_format = r"(\d+) out of (\d+) successful"
        txt_report_from_dir = gh.read_lines("txt-reports/hello-world.txt")
        txt_report_search_cond = [
            "True" for line in txt_report_from_dir if re.search(txt_report_format, line)
        ].pop(0)
        # TODO/(BUG?): my_re.search returns NoneType, find a way to return bool
        self.assertEqual(txt_report_search_cond, "True")

    def test_no_report_option(self):
        """Tests no report option"""
        self.temp = gh.create_temp_file(contents="")
        gh.run(f"./tom_batspp_report.py --force --no > {self.temp}")
        no_report_command_output = gh.read_lines(self.temp)
        no_report_indicator = ">> SKIPPING BATSPP CHECK (-n ARGUMENT PROVIDED)"
        # LACKING: assertEqual cannot compare other types than "str"
        is_no_report = str(
            True if no_report_indicator in no_report_command_output else False
        )
        self.assertEqual(is_no_report, "True")

    def test_count_avoided_testfiles(self):
        """Tests counts of avoided testfiles"""
        # Atleast one test has "NOBATSPP" suffix
        # TODO: Use my_re instead of re for pattern searching
        avoided_pattern = r"No\. of AVOIDED testfiles: (\d+)"
        self.temp = gh.create_temp_file(contents="")
        gh.run(f"./tom_batspp_report.py --force --no > {self.temp}")
        command_output = gh.read_lines(self.temp)
        count_avoided_testfiles_statement = [
            line for line in command_output if re.search(avoided_pattern, line)
        ].pop(0)
        count_avoided_testfiles = int(count_avoided_testfiles_statement[-1])
        is_avoided_testfiles = "True" if count_avoided_testfiles != 0 else "False"
        self.assertEqual(is_avoided_testfiles, "True")

    def test_count_all_testfiles(self):
        """Tests counts of all testfiles"""
        # Complement process of test_count_avoided_testfiles
        avoided_pattern = r"No\. of AVOIDED testfiles: (\d+)"
        self.temp = gh.create_temp_file(contents="")
        gh.run(f"./tom_batspp_report.py --force --no --all > {self.temp}")
        command_output = gh.read_lines(self.temp)
        count_avoided_testfiles_statement = [
            line for line in command_output if my_re.search(avoided_pattern, line)
        ].pop(0)
        count_avoided_testfiles = int(count_avoided_testfiles_statement[-1])
        is_avoided_testfiles = "True" if count_avoided_testfiles == 0 else "False"
        self.assertEqual(is_avoided_testfiles, "True")

    def test_warnings(self):
        """Tests warning generated by script"""
        warning_message = "Error: running under admin account requires --force option"
        self.temp = gh.create_temp_file(contents="")
        gh.run(f"./tom_batspp_report.py --no > {self.temp} 2>&1")
        command_output = gh.read_lines(self.temp)
        self.assertEqual(command_output.pop(0), warning_message)

    @pytest.mark.xfail
    def test_kcov_reports(self):
        """Tests kcov report generation"""
        ## WORK-IN-PROGRESS
        assert (False)

    def test_switch_option(self):
        """Tests --switch options in script"""
        switch_pattern = "simple_batspp.py used:"
        self.temp = gh.create_temp_file(contents="")
        gh.run(f"./tom_batspp_report.py --force --switch > {self.temp}")
        command_output = gh.read_lines(self.temp)
        switch_statement = [
            line for line in command_output if re.search(switch_pattern, line)
        ].pop(0)
        switch_statement_result = (
            switch_statement[switch_statement.rfind(" ") + 1 :]
            if " " in switch_statement
            else switch_statement
        )
        self.assertEqual(switch_statement_result, "True")

    @pytest.mark.xfail
    def test_env_variables(self):
        """Tests environment variables in script"""
        assert (False)


if __name__ == "__main__":
    unittest.main()
